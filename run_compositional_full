# ============================================
# üîß Setup inicial do ambiente (instala pacotes necess√°rios)
# ============================================
!pip install scikit-bio statsmodels pyreadstat seaborn

# ============================================
# üß† Script principal ‚Äî An√°lise Composicional Completa
# ============================================
def run_compositional_full():
    import pandas as pd
    import numpy as np
    import matplotlib.pyplot as plt
    import seaborn as sns
    import statsmodels.formula.api as smf
    from statsmodels.stats.anova import anova_lm
    import statsmodels.api as sm
    from skbio.stats.composition import closure, sbp_basis
    import pyreadstat, os
    from mpl_toolkits.mplot3d import Axes3D
    from google.colab import files   # ‚úÖ compat√≠vel com Colab

    # =========================
    # 1Ô∏è‚É£ Upload do arquivo no Colab
    # =========================
    print("üì§ Fa√ßa upload do arquivo (.sav ou .xlsx) para iniciar a an√°lise:")
    uploaded = files.upload()  # abre seletor de arquivo
    if not uploaded:
        print("‚ùå Nenhum arquivo selecionado.")
        return
    caminho = list(uploaded.keys())[0]
    print(f"\nüìÇ Arquivo carregado: {caminho}")

    # =========================
    # 2Ô∏è‚É£ Leitura do arquivo
    # =========================
    if caminho.endswith(".sav"):
        try:
            df, meta = pyreadstat.read_sav(caminho, encoding='latin1')
        except:
            df, meta = pyreadstat.read_sav(caminho, encoding='windows-1252')
        print("‚úÖ Arquivo SAV lido com sucesso!")
    else:
        df = pd.read_excel(caminho)
        print("‚úÖ Arquivo Excel lido com sucesso!")

    print(f"‚Üí Linhas: {df.shape[0]} | Colunas: {df.shape[1]}")

    # =========================
    # 3Ô∏è‚É£ Detectar tipo de base
    # =========================
    if set(["SB__Butte", "LPA_Butte", "MVPA_Butte"]).issubset(df.columns):
        tipo = "school"
        total = 600
        print("\nüîπ Detectado: df_school (600 min)")
    elif set(["Sleep_time_min", "Avg_sedentary", "Avg_light", "Avg_MVPA"]).issubset(df.columns):
        tipo = "geral"
        total = 1440
        print("\nüîπ Detectado: df geral (1440 min)")
    else:
        print("‚ö†Ô∏è Estrutura da base n√£o reconhecida.")
        return

    # =========================
    # 4Ô∏è‚É£ Limpeza
    # =========================
    df = df.dropna(how="all").reset_index(drop=True)
    if tipo == "school":
        cols = ["SB__Butte", "LPA_Butte", "MVPA_Butte"]
    else:
        cols = ["Sleep_time_min", "Avg_sedentary", "Avg_light", "Avg_MVPA"]
    df = df.dropna(subset=cols)
    df[cols] = df[cols].apply(pd.to_numeric, errors="coerce")
    df = df[(df[cols] > 0).all(axis=1)].reset_index(drop=True)
    print("‚úÖ Dados limpos.")

    # =========================
    # 5Ô∏è‚É£ Plot de M√©dias Composicionais
    # =========================
    print("\nüìà Plotando m√©dias composicionais...")

    if tipo == "school":
        p_sb = df["SB__Butte"].mean() / total
        p_lpa = df["LPA_Butte"].mean() / total
        p_mvpa = df["MVPA_Butte"].mean() / total

        labels = ["SB", "LPA", "MVPA"]
        values = np.array([p_sb, p_lpa, p_mvpa]) * total
        colors = ['#1f77b4', '#2ca02c', '#d62728']

        fig, ax = plt.subplots(figsize=(8, 4))
        bars = ax.barh(labels, values, color=colors)
        for bar in bars:
            width = bar.get_width()
            ax.text(width + 5, bar.get_y() + bar.get_height()/2,
                    f'{width:.1f} min', va='center', fontsize=10)
        ax.set_xlim(0, total)
        ax.set_xlabel("Tempo (min)")
        ax.set_title("Compositional Means ‚Äî df_school (Total = 600 min)")
        plt.tight_layout()
        plt.show()

    else:
        p_sleep = df["Sleep_time_min"].mean() / total
        p_sb = df["Avg_sedentary"].mean() / total
        p_lpa = df["Avg_light"].mean() / total
        p_mvpa = df["Avg_MVPA"].mean() / total

        labels = ["Sleep", "SB", "LPA", "MVPA"]
        values = np.array([p_sleep, p_sb, p_lpa, p_mvpa]) * total
        colors = ['#9467bd', '#1f77b4', '#2ca02c', '#d62728']

        fig, ax = plt.subplots(figsize=(8, 4))
        bars = ax.barh(labels, values, color=colors)
        for bar in bars:
            width = bar.get_width()
            ax.text(width + 10, bar.get_y() + bar.get_height()/2,
                    f'{width:.1f} min', va='center', fontsize=10)
        ax.set_xlim(0, total)
        ax.set_xlabel("Tempo (min)")
        ax.set_title("Compositional Means ‚Äî df (Total = 1440 min)")
        plt.tight_layout()
        plt.show()

    # =========================
    # 6Ô∏è‚É£ Modelos e Gr√°ficos
    # =========================
    if tipo == "school":
        sb = df["SB__Butte"]; lpa = df["LPA_Butte"]; mvpa = df["MVPA_Butte"]
        comp = pd.concat([sb, lpa, mvpa], axis=1)
        comp.columns = ["SB", "LPA", "MVPA"]
        comp_closed = closure(comp.values)
        m = np.mean(comp_closed, axis=0)

        sbp = np.array([[1, 1, -1], [1, -1, 0]])
        V = sbp_basis(sbp)
        ilr_coords = np.log(comp_closed) @ V.T
        df_ilr = pd.DataFrame(ilr_coords, columns=["ilr1", "ilr2"])
        df_ilr["sex"] = df["SEX_1"].astype("category")
        sex_ref = df_ilr["sex"].mode()[0]

        desfechos = ["BMI", "TOTALSCORE", "LOCOMOTION", "MANIPULATION"]
        print("\nüöÄ Modelo composicional (600 min) iniciado.")

        def ilr_transform(x): return np.log(x) @ V.T

        for resp in desfechos:
            if resp not in df.columns: continue
            df_ilr[resp] = df[resp]
            model = smf.ols(f"{resp} ~ ilr1 + ilr2 + sex", data=df_ilr).fit()
            print(f"\nüìä Modelo {resp}:")
            print(model.summary())
            print(anova_lm(model))

            # Realoca√ß√µes
            PAI_NOMES = ['SB', 'LPA', 'MVPA']
            PARES = [(0,1),(0,2),(1,0),(1,2),(2,0),(2,1)]
            minute_range = np.arange(-30,31,1)
            delta = minute_range / total
            mean_ilr = ilr_transform(m)
            pred_mean = model.predict(pd.DataFrame({"ilr1":[mean_ilr[0]],"ilr2":[mean_ilr[1]],"sex":[sex_ref]}))[0]

            fig, axes = plt.subplots(2, 3, figsize=(15,7))
            axes = axes.ravel()
            fig.suptitle(f"Realoca√ß√µes ‚Äî {resp} (600 min)")
            for ax,(i_from,i_to) in zip(axes,PARES):
                reg=[]
                for d,min_shift in zip(delta,minute_range):
                    if m[i_from]-d<0 or m[i_to]+d<0: continue
                    m_mod=m.copy(); m_mod[i_from]-=d; m_mod[i_to]+=d; m_mod=closure(m_mod)
                    ilr_mod=ilr_transform(m_mod)
                    pred=float(model.predict(pd.DataFrame({"ilr1":[ilr_mod[0]],"ilr2":[ilr_mod[1]],"sex":[sex_ref]}))[0])
                    reg.append({"minutos":min_shift,"pred":pred})
                if not reg: ax.axis("off"); continue
                dfp=pd.DataFrame(reg)
                ax.plot(dfp["minutos"],dfp["pred"],marker="o")
                ax.axhline(pred_mean,color="gray",linestyle="--")
                ax.set_title(f"{PAI_NOMES[i_from]}‚Üí{PAI_NOMES[i_to]}")
            plt.tight_layout(); plt.show()

            # Superf√≠cies 3D
            pares=[(0,1,"SB & LPA"),(0,2,"SB & MVPA"),(1,2,"LPA & MVPA")]
            for (i,j,tit) in pares:
                X,Y=np.meshgrid(np.arange(-30,31,3),np.arange(-30,31,3))
                Z=np.full_like(X,np.nan,dtype=float)
                for r in range(X.shape[0]):
                    for c in range(X.shape[1]):
                        di,dj=X[r,c]/total,Y[r,c]/total
                        m_i,m_j=m[i]+di,m[j]+dj;m_k=1-m_i-m_j
                        if (m_i<=0)|(m_j<=0)|(m_k<=0): continue
                        vec=closure([m_i,m_j,m_k])
                        ilr=ilr_transform(vec)
                        Z[r,c]=float(model.predict(pd.DataFrame({"ilr1":[ilr[0]],"ilr2":[ilr[1]],"sex":[sex_ref]}))[0])
                mask=~np.isnan(Z)
                fig=plt.figure(figsize=(6,5))
                ax=fig.add_subplot(111,projection='3d')
                ax.plot_trisurf(X[mask],Y[mask],Z[mask],linewidth=0.2)
                ax.set_title(f"{resp} ‚Äî {tit}")
                ax.set_xlabel("Œîmin i"); ax.set_ylabel("Œîmin j"); ax.set_zlabel("Predi√ß√£o")
                plt.show()

    else:
        # -------------------------
        # Vers√£o 1440 min
        # -------------------------
        sleep = df["Sleep_time_min"]; sb = df["Avg_sedentary"]
        lpa = df["Avg_light"]; mvpa = df["Avg_MVPA"]
        comp = pd.concat([sleep,sb,lpa,mvpa],axis=1)
        comp.columns = ["Sleep","SB","LPA","MVPA"]
        comp_closed = closure(comp.values)
        m = np.mean(comp_closed, axis=0)

        sbp = np.array([[1,-1,-1,-1],[0,1,-1,-1],[0,0,1,-1]])
        V = sbp_basis(sbp)
        ilr_coords = np.log(comp_closed) @ V.T
        df_ilr = pd.DataFrame(ilr_coords, columns=["ilr1","ilr2","ilr3"])
        df_ilr["sex"] = df["Sex"].astype("category")
        sex_ref = df_ilr["sex"].mode()[0]

        desfechos = ["BMI","Laps","agility_coord","horizontal_jump"]
        print("\nüöÄ Modelo composicional (1440 min) iniciado.")

        def ilr_transform(x): return np.log(x) @ V.T

        for resp in desfechos:
            if resp not in df.columns: continue
            df_ilr[resp] = df[resp]
            model = smf.ols(f"{resp} ~ ilr1 + ilr2 + ilr3 + sex", data=df_ilr).fit()
            print(f"\nüìä Modelo {resp}:")
            print(model.summary())
            print(anova_lm(model))

            # Realoca√ß√µes
            PAI_NOMES=['Sleep','SB','LPA','MVPA']
            PARES=[(i,j) for i in range(4) for j in range(4) if i!=j]
            minute_range=np.arange(-30,31,1)
            delta=minute_range/total
            mean_ilr=ilr_transform(m)
            pred_mean=float(model.predict(pd.DataFrame({"ilr1":[mean_ilr[0]],"ilr2":[mean_ilr[1]],"ilr3":[mean_ilr[2]],"sex":[sex_ref]}))[0])

            fig,axes=plt.subplots(3,4,figsize=(20,9));axes=axes.ravel()
            fig.suptitle(f"Realoca√ß√µes ‚Äî {resp} (1440 min)")
            for ax,(i_from,i_to) in zip(axes,PARES):
                reg=[]
                for d,min_shift in zip(delta,minute_range):
                    if m[i_from]-d<0 or m[i_to]+d<0: continue
                    m_mod=m.copy();m_mod[i_from]-=d;m_mod[i_to]+=d;m_mod=closure(m_mod)
                    ilr_mod=ilr_transform(m_mod)
                    pred=float(model.predict(pd.DataFrame({"ilr1":[ilr_mod[0]],"ilr2":[ilr_mod[1]],"ilr3":[ilr_mod[2]],"sex":[sex_ref]}))[0])
                    reg.append({"minutos":min_shift,"pred":pred})
                if not reg: ax.axis("off"); continue
                dfp=pd.DataFrame(reg)
                ax.plot(dfp["minutos"],dfp["pred"],marker="o")
                ax.axhline(pred_mean,color="gray",linestyle="--")
                ax.set_title(f"{PAI_NOMES[i_from]}‚Üí{PAI_NOMES[i_to]}")
            plt.tight_layout();plt.show()

            # Superf√≠cies 3D
            pares=[(1,3,"SB & MVPA"),(2,3,"LPA & MVPA"),(0,1,"Sleep & SB")]
            for (i,j,tit) in pares:
                X,Y=np.meshgrid(np.arange(-30,31,3),np.arange(-30,31,3))
                Z=np.full_like(X,np.nan,dtype=float)
                for r in range(X.shape[0]):
                    for c in range(X.shape[1]):
                        di,dj=X[r,c]/total,Y[r,c]/total
                        m_i=m[i]+di;m_j=m[j]+dj;resto=1-m_i-m_j
                        if resto<=0: continue
                        prop_fix=m[[k for k in range(4) if k not in [i,j]]];prop_fix/=prop_fix.sum()
                        fix=resto*prop_fix
                        vec=np.zeros(4);vec[i]=m_i;vec[j]=m_j
                        vec[[k for k in range(4) if k not in [i,j]]]=fix
                        vec=closure(vec)
                        ilr=ilr_transform(vec)
                        Z[r,c]=float(model.predict(pd.DataFrame({"ilr1":[ilr[0]],"ilr2":[ilr[1]],"ilr3":[ilr[2]],"sex":[sex_ref]}))[0])
                mask=~np.isnan(Z)
                fig=plt.figure(figsize=(6,5))
                ax=fig.add_subplot(111,projection='3d')
                ax.plot_trisurf(X[mask],Y[mask],Z[mask],linewidth=0.2)
                ax.set_title(f"{resp} ‚Äî {tit}")
                ax.set_xlabel("Œîmin i"); ax.set_ylabel("Œîmin j"); ax.set_zlabel("Predi√ß√£o")
                plt.show()

    print("\n‚úÖ An√°lise composicional conclu√≠da com sucesso!")

# ============================================
# ‚ñ∂Ô∏è Executar
# ============================================
run_compositional_full()
